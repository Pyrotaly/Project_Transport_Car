local grid = require("main._scripts.modules.road_quadrants")
local fsm = require ("main._scripts.modules.fsm")
math.randomseed(os.time())

-- Driving Up and Swaying
go.property("sway_distance", 20) -- Sway distance (up/down)
go.property("sway_speed", 3.0) -- Sway speed
go.property("sway_side_distance", 3) -- Sideways sway distance
go.property("back_distance", 20) -- How much the car moves backward after arriving

-- ---------------------------------------------------------
-- Charge Attack
-- ---------------------------------------------------------
local function start_charge(self)
	local current_pos = go.get_position()
	local player_pos = go.get_position("/player/player")

	local direction = vmath.normalize(player_pos - current_pos)
	self.velocity = direction * self.speed

	local distance = vmath.length(player_pos - current_pos)

	local min_duration = 0.25  -- Adjust as needed
	local max_duration = 1.3  -- Adjust as needed

	local raw_duration = distance / self.speed
	self.charge_duration = math.max(min_duration, math.min(raw_duration, max_duration)) + 0.25

	print("Charge duration:", self.charge_duration)

	-- Start charging
	self.charging = true
	self.charge_timer = 0
end

local function stop_charge(self)
	self.charging = false
	self.velocity = vmath.vector3(0) -- Stop moving
end

-- ---------------------------------------------------------
-- Driving Up and Swaying
-- ---------------------------------------------------------
local function sway_up(self)
	if self.arrived then
		go.animate(".", "position.y", go.PLAYBACK_ONCE_PINGPONG, go.get_position().y + self.sway_distance, go.EASING_INOUTSINE, self.sway_speed, 0, sway_up)
	end
end

local function sway_left_right(self)
	if self.arrived then
		go.animate(".", "position.x", go.PLAYBACK_ONCE_PINGPONG, go.get_position().x + self.sway_side_distance, go.EASING_INOUTSINE, self.sway_speed * 1.2, 0, sway_left_right)
	end
end

local function swaying(self)
	sway_up(self)
	sway_left_right(self)
end

local function move_back(self)
	go.animate(".", "position.x", go.PLAYBACK_ONCE_FORWARD, self.target_x - self.back_distance * 2, go.EASING_INOUTSINE, 1, 0, function()
		-- Start swaying motion after moving back
		self.arrived = true
		swaying(self)
	end)
end

-- ---------------------------------------------------------
-- Movement
-- ---------------------------------------------------------
local function move_to_quadrant(self, quadrant)
	print(quadrant)
	-- TODO : somehow, can get numbers of range outside of 1-25, put check here or sometin idk
	if not grid.is_occupied(quadrant) then
		local target_pos = grid.get_quadrant_position(quadrant)

		go.animate(".", "position.x", go.PLAYBACK_ONCE_FORWARD, target_pos.x, go.EASING_LINEAR, 1.5)
		go.animate(".", "position.y", go.PLAYBACK_ONCE_FORWARD, target_pos.y, go.EASING_LINEAR, 1.5)

		-- Set the current quadrant as unoccupied
		if self.current_quadrant then
			grid.set_occupied(self.current_quadrant, false)
		end

		-- Move to the new quadrant and mark it as occupied
		self.current_quadrant = quadrant
		grid.set_occupied(quadrant, true)
	else
		-- If the target quadrant is occupied, retry by picking another quadrant
		print("Quadrant " .. quadrant .. " is occupied, selecting a new quadrant.")
		local available_quadrants = grid.get_available_quadrants()  -- Assuming you have a way to get all available quadrants
		local new_quadrant = available_quadrants[math.random(#available_quadrants)]
		move_to_quadrant(self, new_quadrant)
	end
end

local function move_nearby(self)
	local new_quad = grid.get_random_nearby_quadrant(self.current_quadrant, 2)

	move_to_quadrant(self, new_quad)
end

-- --------------------------------------
-- FSM Management
-- --------------------------------------
-- idle is car in same quadrant but swaying
local state_manager = fsm.create({
	initial = "init",
	events = {
		{name = "init_to_idle", from = "init", to = "idle"},
		{name = "idle_to_charge", from = "idle", to = "charge"},
		{name = "charge_to_idle", from = "charge", to = "idle"},
		{name = "idle_to_move", from = "idle", to = "move"},
		{name = "move_to_idle", from = "move", to = "idle"}
	},
	callbacks = {
		on_enter_charge = function(self)
			start_charge(self) -- Start the charge behavior
		end,
		on_exit_charge = function(self)
			stop_charge(self) -- Stop the charge behavior
		end,
		on_enter_idle = function(self)
			print("Entering idle state...")
			-- Add idle-specific logic here, if needed
		end,
		on_enter_init = function(self)
			print("Entering init state...")
			
		end
	}
})


-- ---------------------------------------------------------
-- Main
-- ---------------------------------------------------------
function init(self)
	-- Charging properties
	self.velocity = vmath.vector3(0) -- Initialize the velocity to zero
	self.speed = 1000 -- Set the charge speed (units per second)
	self.charging = false -- Whether the enemy is currently charging
	self.charge_timer = 0 -- Timer for the current charge
	self.cooldown_timer = 0 -- Timer for the cooldown between charges
	self.charge_cooldown = 2 -- Time between charges (in seconds)
	self.damage = 10 -- Damage dealt to the player on collision

	-- Driving up
	self.target_x = go.get_position().x
	self.arrived = false
	self.start_x = -100
	self.start_y = go.get_position().y
	go.set_position(vmath.vector3(self.start_x, self.start_y, 0))
	go.animate(".", "position.x", go.PLAYBACK_ONCE_FORWARD, self.target_x, go.EASING_OUTQUAD, 2, 0, function()
		move_back(self)
	end)
end

function final(self)
	-- Add finalization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function update(self, dt)
	-- Handle charging movement
	if self.charging then
		-- Update position based on velocity
		local new_pos = go.get_position() + self.velocity * dt
		go.set_position(new_pos)

		-- Increment the charge timer
		self.charge_timer = self.charge_timer + dt

		-- Stop charging after the charge duration
		if self.charge_timer >= self.charge_duration then
			state_manager:charge_to_idle()
		end
	end
end


function fixed_update(self, dt)
	-- This function is called if 'Fixed Update Frequency' is enabled in the Engine section of game.project
	-- Can be coupled with fixed updates of the physics simulation if 'Use Fixed Timestep' is enabled in
	-- Physics section of game.project
	-- Add update code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function on_message(self, message_id, message, sender)
	-- Add message-handling code here
	-- Learn more: https://defold.com/manuals/message-passing/
	-- Remove this function if not needed
end

function on_input(self, action_id, action)
	-- Add input-handling code here. The game object this script is attached to
	-- must have acquired input focus:
	--
	--    msg.post(".", "acquire_input_focus")
	--
	-- All mapped input bindings will be received. Mouse and touch input will
	-- be received regardless of where on the screen it happened.
	-- Learn more: https://defold.com/manuals/input/
	-- Remove this function if not needed
end

function on_reload(self)
	-- Add reload-handling code here
	-- Learn more: https://defold.com/manuals/hot-reload/
	-- Remove this function if not needed
end
